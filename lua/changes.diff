diff -u original-src/llimits.h src/llimits.h
--- original-src/llimits.h	2020-04-12 21:11:37.092326257 -0600
+++ src/llimits.h	2020-04-20 23:33:52.138741348 -0600
@@ -84,6 +84,9 @@
 typedef LUAI_UACINT l_uacInt;
 
 
+#undef NDEBUG
+#include <assert.h>
+#define lua_assert(c) assert(c)
 /* internal assertions for in-house debugging */
 #if defined(lua_assert)
 #define check_exp(c,e)		(lua_assert(c), (e))
diff -u original-src/lua.h src/lua.h
--- original-src/lua.h	2020-04-12 21:11:37.092326257 -0600
+++ src/lua.h	2020-04-18 04:07:59.742585602 -0600
@@ -9,12 +9,15 @@
 #ifndef lua_h
 #define lua_h
 
+#include <emscripten.h>
 #include <stdarg.h>
 #include <stddef.h>
 
 
 #include "luaconf.h"
 
+extern unsigned int feels_vm_delay;
+extern int feels_opcode_count;
 
 #define LUA_VERSION_MAJOR	"5"
 #define LUA_VERSION_MINOR	"4"
diff -u original-src/lvm.c src/lvm.c
--- original-src/lvm.c	2020-04-12 21:11:37.088992932 -0600
+++ src/lvm.c	2020-04-20 23:44:35.768263719 -0600
@@ -30,6 +30,7 @@
 #include "ltm.h"
 #include "lvm.h"
 
+#define LUA_USE_JUMPTABLE 0
 
 /*
 ** By default, use jump tables in the main interpreter loop on gcc
@@ -1079,6 +1080,34 @@
     Instruction i;  /* instruction being executed */
     StkId ra;  /* instruction's A register */
     vmfetch();
+
+    // ignore the VARARGPREP instruction that comes at the beginning of every bit of code ran by the REPL.
+    if (!(ci->previous && ci->previous->previous == NULL && GET_OPCODE(i) == OP_VARARGPREP)) {
+      if (feels_opcode_count > 0) {
+        emscripten_sleep(feels_vm_delay);
+      }
+      OpCode opcode = GET_OPCODE(i);
+      if (opcode == OP_ADD) {
+        TValue *v1 = vRB(i);
+        TValue *v2 = vRC(i);
+        if (ttisinteger(v1) && ttisinteger(v2)) {
+          lua_Integer i1 = ivalue(v1); lua_Integer i2 = ivalue(v2);
+          EM_ASM({
+            lua_event('opcode ' + $0 + ' ' + $1 + ' ' + $2);
+          }, (int32_t)opcode, (int32_t)i1, (int32_t)i2);
+        } else {
+          EM_ASM({
+            lua_event('opcode ' + $0);
+          }, (int32_t)opcode);
+        }
+      } else {
+        EM_ASM({
+          lua_event('opcode ' + $0);
+        }, (int32_t)opcode);
+      }
+      feels_opcode_count++;
+    }
+
     lua_assert(base == ci->func + 1);
     lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
     /* invalidate top for instructions not expecting it */
