diff -u original-src/llimits.h src/llimits.h
--- original-src/llimits.h	2020-04-12 21:11:37.092326257 -0600
+++ src/llimits.h	2020-04-13 20:00:21.109680535 -0600
@@ -84,6 +84,9 @@
 typedef LUAI_UACINT l_uacInt;
 
 
+#undef NDEBUG
+#include <assert.h>
+#define lua_assert(c) assert(c)
 /* internal assertions for in-house debugging */
 #if defined(lua_assert)
 #define check_exp(c,e)		(lua_assert(c), (e))
diff -u original-src/lua.h src/lua.h
--- original-src/lua.h	2020-04-12 21:11:37.092326257 -0600
+++ src/lua.h	2020-04-18 04:07:59.742585602 -0600
@@ -9,12 +9,15 @@
 #ifndef lua_h
 #define lua_h
 
+#include <emscripten.h>
 #include <stdarg.h>
 #include <stddef.h>
 
 
 #include "luaconf.h"
 
+extern unsigned int feels_vm_delay;
+extern int feels_opcode_count;
 
 #define LUA_VERSION_MAJOR	"5"
 #define LUA_VERSION_MINOR	"4"
diff -u original-src/lvm.c src/lvm.c
--- original-src/lvm.c	2020-04-12 21:11:37.088992932 -0600
+++ src/lvm.c	2020-04-18 04:09:08.165813436 -0600
@@ -30,6 +30,7 @@
 #include "ltm.h"
 #include "lvm.h"
 
+#define LUA_USE_JUMPTABLE 0
 
 /*
 ** By default, use jump tables in the main interpreter loop on gcc
@@ -1079,6 +1080,18 @@
     Instruction i;  /* instruction being executed */
     StkId ra;  /* instruction's A register */
     vmfetch();
+
+    // ignore the VARARGPREP instruction that comes at the beginning of every bit of code ran by the REPL.
+    if (!(ci->previous && ci->previous->previous == NULL && GET_OPCODE(i) == OP_VARARGPREP)) {
+      if (feels_opcode_count > 0) {
+        emscripten_sleep(feels_vm_delay);
+      }
+      EM_ASM({
+        lua_event('opcode ' + $0);
+      }, GET_OPCODE(i));
+      feels_opcode_count++;
+    }
+
     lua_assert(base == ci->func + 1);
     lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
     /* invalidate top for instructions not expecting it */
